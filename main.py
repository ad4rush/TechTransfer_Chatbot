# app.py
import streamlit as st
import os
import json
import config
from pdf_utils import process_pdf
from chatbot import initialize_chat, get_questions, generate_answer
from datetime import datetime


# Configuration
GEMINI_API_KEY = config.GOOGLE_API_KEY
OUTPUT_TEXT_FILE = "extracted_text.txt"
IMAGES_FOLDER = "extracted_images"

# Session state initialization
if 'processed' not in st.session_state:
    st.session_state.update({
        'processed': False,
        'chat_initialized': False,
        'current_question': 0,
        'questions': get_questions(),
        'answers': {},
        'feedback_history': {},
        'manual_edits': {}
    })

st.title("Tech Transfer ChatBot")

# 1. PDF Processing Section (unchanged)
uploaded_file = st.file_uploader("Upload Research PDF", type=["pdf"])
if uploaded_file and not st.session_state.processed:
    with st.spinner("Processing PDF..."):
        with open("temp.pdf", "wb") as f:
            f.write(uploaded_file.getbuffer())
        
        process_pdf("temp.pdf", OUTPUT_TEXT_FILE, IMAGES_FOLDER, GEMINI_API_KEY)
        st.session_state.pdf_text = open(OUTPUT_TEXT_FILE).read()
        st.session_state.processed = True
        st.session_state.chat = initialize_chat(GEMINI_API_KEY)
        
    st.success("PDF processed successfully!")
    st.download_button(
        label="Download Extracted Text",
        data=open(OUTPUT_TEXT_FILE, "rb").read(),
        file_name="extracted_text.txt",
        mime="text/plain"
    )

import asyncio
from playwright.async_api import async_playwright

async def html_to_pdf(html_content, output_path):
    async with async_playwright() as p:
        browser = await p.chromium.launch()
        page = await browser.new_page()
        await page.set_content(html_content)
        await page.pdf(path=output_path)
        await browser.close()

# 2. Q&A Section (modified for PDF and form submission)
if st.session_state.processed:
    st.divider()
    st.header("Your Research Analysis!")
    
        # Update the PDF generation section with proper Unicode handling
    # Replace the existing PDF generation section with this:

    if st.session_state.current_question >= len(st.session_state.questions):
        st.header("âœ… Analysis Complete!")
        st.markdown("### Final Report")
        
        # Generate HTML Report
        html_content = """
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Tech Transfer Research Analysis Report</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 40px; }
                .header { text-align: center; border-bottom: 2px solid #333; margin-bottom: 30px; }
                .section { margin-bottom: 25px; }
                .question { font-weight: bold; color: #2c3e50; font-size: 1.1em; }
                .answer { margin: 10px 0 20px 20px; color: #34495e; line-height: 1.6; }
                .footer { text-align: center; margin-top: 40px; color: #666; }
            </style>
        </head>
        <body>
            <div class="header">
                <h1>Tech Transfer Research Analysis Report</h1>
                <p>Generated by Tech Transfer ChatBot</p>
            </div>
            
        """

        
        # Add questions and answers
        for idx, q_data in enumerate(st.session_state.questions):
            param = q_data["param"]
            question = q_data["question"]
            answer = st.session_state.answers[param]['answer']
            
            html_content += f"""
            <div class="section">
                <div class="question">Question {idx+1}: {question}</div>
                <div class="answer">{answer.replace('\n', '<br>')}</div>
                <div class="history">Edits: {len(st.session_state.answers[param]['versions'])} versions</div>
            </div>
            """
        
        # Add footer
        html_content += """
            <div class="footer">
                <p>Report generated on {datetime}</p>
            </div>
        </body>
        </html>
        """.format(datetime=datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
        
        # Save HTML file
        html_file = "research_analysis.html"
        with open(html_file, "w", encoding="utf-8") as f:
            f.write(html_content)
        
        try:
            
            pdf_file = "research_analysis.pdf"
            # You can use pdfkit.from_string(html_content, pdf_file) as an alternative.
            #HTML(string=html_content).write_pdf(pdf_file)
            asyncio.run(html_to_pdf(html_content, pdf_file))
        except Exception as e:
            st.error("PDF conversion failed.")
            pdf_file = None

        # Download buttons
        col1, col2, col3 = st.columns(3)
        with col1:
            with open(html_file, "rb") as f:
                st.download_button(
                    label="Download Full Report (HTML)",
                    data=f,
                    file_name=html_file,
                    mime="text/html",
                    help="Open in browser and use 'Print > Save as PDF' for PDF version"
                )
        with col2:
            if pdf_file and os.path.exists(pdf_file):
                with open(pdf_file, "rb") as f:
                    st.download_button(
                        label="Download Full Report (PDF)",
                        data=f,
                        file_name=pdf_file,
                        mime="application/pdf"
                    )
            else:
                st.write("PDF not available.")
        with col3:
            if st.button("Upload Another PDF"):
                # Clear session state
                for key in list(st.session_state.keys()):
                    del st.session_state[key]
                st.rerun()


    else:
        questions_per_page = 3  # You can make this 4 if you prefer
        total_questions = len(st.session_state.questions)
        total_pages = (total_questions + questions_per_page - 1) // questions_per_page

        # Initialize current page
        if 'current_page' not in st.session_state:
            st.session_state.current_page = 0

        start_idx = st.session_state.current_page * questions_per_page
        end_idx = min(start_idx + questions_per_page, total_questions)
        current_batch = st.session_state.questions[start_idx:end_idx]

        st.subheader(f"Questions {start_idx+1} to {end_idx} of {total_questions}")

        for i, q_data in enumerate(current_batch):
            param = q_data["param"]
            question = q_data["question"]

            if param not in st.session_state.answers:
                st.session_state.answers[param] = {'answer': '', 'versions': []}
                st.session_state.feedback_history[param] = []

            if not st.session_state.answers[param]['versions']:
                with st.spinner(f"Generating answer for Q{i+1}..."):
                    response = generate_answer(
                        st.session_state.chat,
                        question,
                        st.session_state.pdf_text
                    )
                    st.session_state.answers[param]['versions'].append(response)
                    st.session_state.answers[param]['answer'] = response

            st.markdown(f"---\n### Question {start_idx + i + 1}")
            st.markdown(f"**Parameter:** `{param}`")
            st.markdown(f"**Q:** {question}")

            # Editable Answer
            edited_answer = st.text_area(
                f"Answer for {param}",
                value=st.session_state.answers[param]['answer'],
                height=180,
                key=f"editor_{param}"
            )

            if st.button(f"ðŸ’¾ Save Changes to {param}", key=f"save_{param}"):
                st.session_state.answers[param]['answer'] = edited_answer
                st.session_state.answers[param]['versions'].append(f"Manual edit: {edited_answer}")
                st.success(f"Saved answer for {param}")
                st.rerun()

            # Feedback Expander
            with st.expander(f"ðŸ’¬ Refine Answer for `{param}`"):
                feedback = st.text_area("Enter feedback", key=f"feedback_input_{param}")
                if st.button(f"ðŸ” Refine Answer for {param}", key=f"refine_{param}"):
                    if feedback.strip():
                        st.session_state.feedback_history[param].append(feedback)
                        with st.spinner("Refining..."):
                            prompt = f"{question}\n\nPrevious answer: {edited_answer}\nFeedback: {feedback}"
                            refined_answer = generate_answer(
                                st.session_state.chat,
                                prompt,
                                st.session_state.pdf_text
                            )
                            st.session_state.answers[param]['versions'].append(refined_answer)
                            st.session_state.answers[param]['answer'] = refined_answer
                        st.success("Refinement complete!")
                        st.rerun()
                    else:
                        st.warning("Please provide feedback.")

            # Optional history
            with st.expander("ðŸ•˜ Edit History"):
                for ver_i, version in enumerate(st.session_state.answers[param]['versions'][::-1], 1):
                    st.markdown(f"**Version {ver_i}:** {version}")

        # Navigation
        st.divider()
        col1, col2 = st.columns(2)
        with col1:
            if st.button("â¬… Previous Set", disabled=(st.session_state.current_page == 0)):
                st.session_state.current_page -= 1
                st.rerun()
        with col2:
            if st.button("Next Set âž¡", disabled=(st.session_state.current_page >= total_pages - 1)):
                st.session_state.current_page += 1
                st.rerun()

